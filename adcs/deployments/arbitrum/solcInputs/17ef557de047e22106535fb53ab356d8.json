{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "src/ADCSConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IADCSCoordinator.sol\";\n\nabstract contract ADCSConsumerBase {\n    using ADCS for ADCS.Request;\n\n    struct StringAndBool {\n        string name;\n        bool response;\n    }\n    error OnlyCoordinatorCanFulfill(address have, address want);\n    mapping(bytes32 => bytes4) private sTypeIdToFunctionSelector;\n    IADCSCoordinator public immutable COORDINATOR;\n\n    /**\n     * @param _adcsResponseCoordinator address of ADCSCoordinator contract\n     */\n    constructor(address _adcsResponseCoordinator) {\n        COORDINATOR = IADCSCoordinator(_adcsResponseCoordinator);\n\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"uint256\"))] = COORDINATOR\n            .fulfillDataRequestUint256\n            .selector;\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"bool\"))] = COORDINATOR\n            .fulfillDataRequestBool\n            .selector;\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"bytes32\"))] = COORDINATOR\n            .fulfillDataRequestBytes32\n            .selector;\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"bytes\"))] = COORDINATOR\n            .fulfillDataRequestBytes\n            .selector;\n\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"stringAndbool\"))] = COORDINATOR\n            .fulfillDataRequestStringAndBool\n            .selector;\n    }\n\n    /**\n     * @notice Build a request using the Orakl library\n     * @param jobId the job specification ID that the request is created for\n     * @param typeId the reponse type ID that the request is created for\n     * @return req request in memory\n     */\n    function buildRequest(\n        bytes32 jobId,\n        bytes32 typeId\n    ) internal view returns (ADCS.Request memory req) {\n        return req.initialize(jobId, address(COORDINATOR), sTypeIdToFunctionSelector[typeId]);\n    }\n\n    modifier verifyRawFulfillment() {\n        address coordinatorAddress = address(COORDINATOR);\n        if (msg.sender != coordinatorAddress) {\n            revert OnlyCoordinatorCanFulfill(msg.sender, coordinatorAddress);\n        }\n        _;\n    }\n}\n"
    },
    "src/ADCSConsumerFulfill.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./ADCSConsumerBase.sol\";\n\nabstract contract ADCSConsumerFulfillUint256 is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, uint256 response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        uint256 response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillBool is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, bool response) internal virtual;\n\n    function rawFulfillDataRequest(uint256 requestId, bool response) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillBytes32 is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, bytes32 response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        bytes32 response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillBytes is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, bytes memory response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        bytes memory response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillStringAndBool is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, StringAndBool memory response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        StringAndBool memory response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n"
    },
    "src/interfaces/IADCSCoordinator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./IADCSCoordinatorBase.sol\";\nimport \"./ICoordinatorBase.sol\";\n\ninterface IADCSCoordinator is IADCSCoordinatorBase, ICoordinatorBase {}\n"
    },
    "src/interfaces/IADCSCoordinatorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"../libraries/ADCS.sol\";\n\ninterface IADCSCoordinatorBase {\n    // RequestCommitment holds information sent from off-chain oracle\n    // describing details of request.\n    struct RequestCommitment {\n        uint64 blockNum;\n        uint256 callbackGasLimit;\n        address sender;\n        bytes32 jobId;\n    }\n\n    struct StringAndBool {\n        string name;\n        bool response;\n    }\n\n    function requestData(\n        uint256 callbackGasLimit,\n        ADCS.Request memory req\n    ) external returns (uint256);\n\n    function fulfillDataRequestUint256(\n        uint256 requestId,\n        uint256 response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBool(\n        uint256 requestId,\n        bool response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBytes32(\n        uint256 requestId,\n        bytes32 response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBytes(\n        uint256 requestId,\n        bytes memory response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestStringAndBool(\n        uint256 requestId,\n        StringAndBool memory response,\n        RequestCommitment memory rc\n    ) external;\n}\n"
    },
    "src/interfaces/ICoordinatorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface ICoordinatorBase {\n    /**\n     * @notice Sets the configuration of the VRF coordinator\n     * @param maxGasLimit global max for request gas limit\n     * @param gasAfterPaymentCalculation gas used in doing accounting\n     * after completing the gas measurement\n     */\n    function setConfig(uint256 maxGasLimit, uint256 gasAfterPaymentCalculation) external;\n\n    function pendingRequestExists(address consumer, uint64 nonce) external view returns (bool);\n\n    /**\n     * @notice Get request commitment.\n     * @param requestId id of request\n     * @return commmitment value that can be used to determine whether\n     * a request is fulfilled or not. If `requestId` is valid and\n     * commitment equals to bytes32(0), the request was fulfilled.\n     */\n    function getCommitment(uint256 requestId) external view returns (bytes32);\n\n    /**\n     * @notice Canceling oracle request\n     * @param requestId - ID of the Oracle Request\n     */\n    function cancelRequest(uint256 requestId) external;\n}\n"
    },
    "src/libraries/ADCS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Chainlink.sol\n\nimport {Buffer} from \"./Buffer.sol\";\nimport {CBOR} from \"./CBOR.sol\";\n\nlibrary ADCS {\n    uint256 internal constant defaultBufferSize = 256;\n\n    using CBOR for Buffer.buffer;\n\n    // structure for storing requests done off-chain\n    struct Request {\n        bytes32 id;\n        address callbackAddr;\n        bytes4 callbackFunc;\n        uint256 nonce;\n        Buffer.buffer buf;\n    }\n\n    /**\n     * @notice Initializes a request\n     * @dev Sets ID, callback address, and callback function\n     * @param self The uninitialized request\n     * @param jobId The Job Specification ID\n     * @param callbackAddr The callback address\n     * @param callbackFunc The callback function signature\n     * @return The initialized request\n     */\n    function initialize(\n        Request memory self,\n        bytes32 jobId,\n        address callbackAddr,\n        bytes4 callbackFunc\n    ) internal pure returns (ADCS.Request memory) {\n        Buffer.init(self.buf, defaultBufferSize);\n        self.id = jobId;\n        self.callbackAddr = callbackAddr;\n        self.callbackFunc = callbackFunc;\n        return self;\n    }\n\n    /**\n     * @notice sets the data for buffer\n     * @param _request the initialized request\n     * @param _data the CBOR data\n     */\n    function setBuffer(Request memory _request, bytes memory _data) internal pure {\n        Buffer.init(_request.buf, _data.length);\n        Buffer.append(_request.buf, _data);\n    }\n\n    /**\n     * @notice Adds a string value to the request in a key - value pair format\n     * @param self - the initalized request\n     * @param key - the name of the key\n     * @param value - the string value to add\n     */\n    function add(Request memory self, string memory key, string memory value) internal pure {\n        self.buf.encodeString(key);\n        self.buf.encodeString(value);\n    }\n\n    /**\n     * @notice Adds a byte value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the bytes value to add\n     */\n    function addBytes(\n        Request memory _request,\n        string memory _key,\n        bytes memory _value\n    ) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeBytes(_value);\n    }\n\n    /**\n     * @notice Adds a Int256 value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the int256 value to add\n     */\n    function addInt(Request memory _request, string memory _key, int256 _value) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeInt(_value);\n    }\n\n    /**\n     * @notice Adds a UInt256 value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the uint256 value to add\n     */\n    function addUInt(Request memory _request, string memory _key, uint256 _value) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeUInt(_value);\n    }\n\n    /**\n     * @notice Adds an array of string value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _values - the array of string value to add\n     */\n    function addStringArray(\n        Request memory _request,\n        string memory _key,\n        string[] memory _values\n    ) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.startArray();\n        for (uint256 i; i < _values.length; i++) {\n            _request.buf.encodeString(_values[i]);\n        }\n        _request.buf.endSequence();\n    }\n}\n"
    },
    "src/libraries/Buffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary Buffer {\n    /**\n     * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n     *      a capacity. The capacity may be longer than the current value, in\n     *      which case it can be extended without the need to allocate more memory.\n     */\n    struct buffer {\n        bytes buf;\n        uint256 capacity;\n    }\n\n    /**\n     * @dev Initializes a buffer with an initial capacity.\n     * @param buf The buffer to initialize.\n     * @param capacity The number of bytes of space to allocate the buffer.\n     * @return The buffer, for chaining.\n     */\n    function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Initializes a new buffer from an existing bytes object.\n     *      Changes to the buffer may mutate the original value.\n     * @param b The bytes object to initialize the buffer with.\n     * @return A new buffer.\n     */\n    function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint256 capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint256 a, uint256 b) private pure returns (uint256) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n\n    /**\n     * @dev Sets buffer length to 0.\n     * @param buf The buffer to truncate.\n     * @return The original buffer, for chaining..\n     */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function write(\n        buffer memory buf,\n        uint256 off,\n        bytes memory data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint256 dest;\n        uint256 src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint256 mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function append(\n        buffer memory buf,\n        bytes memory data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, len);\n    }\n\n    /**\n     * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    /**\n     * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write the byte at.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function writeUint8(\n        buffer memory buf,\n        uint256 off,\n        uint8 data\n    ) internal pure returns (buffer memory) {\n        if (off >= buf.capacity) {\n            resize(buf, buf.capacity * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if eq(off, buflen) {\n                mstore(bufptr, add(buflen, 1))\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n        return writeUint8(buf, buf.buf.length, data);\n    }\n\n    /**\n     * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @param len The number of bytes to write (left-aligned).\n     * @return The original buffer, for chaining.\n     */\n    function write(\n        buffer memory buf,\n        uint256 off,\n        bytes32 data,\n        uint256 len\n    ) private pure returns (buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        unchecked {\n            uint256 mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + off + len\n                let dest := add(add(bufptr, off), len)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(add(off, len), mload(bufptr)) {\n                    mstore(bufptr, add(off, len))\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function writeBytes20(\n        buffer memory buf,\n        uint256 off,\n        bytes20 data\n    ) internal pure returns (buffer memory) {\n        return write(buf, off, bytes32(data), 20);\n    }\n\n    /**\n     * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chhaining.\n     */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, bytes32(data), 20);\n    }\n\n    /**\n     * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, 32);\n    }\n\n    /**\n     * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer, for chaining.\n     */\n    function writeInt(\n        buffer memory buf,\n        uint256 off,\n        uint256 data,\n        uint256 len\n    ) private pure returns (buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        uint256 mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + off + sizeof(buffer length) + len\n            let dest := add(add(bufptr, off), len)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(add(off, len), mload(bufptr)) {\n                mstore(bufptr, add(off, len))\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     * exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer.\n     */\n    function appendInt(\n        buffer memory buf,\n        uint256 data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        return writeInt(buf, buf.buf.length, data, len);\n    }\n}\n"
    },
    "src/libraries/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vendor/CBORChainlink.sol\n\nimport {Buffer} from \"./Buffer.sol\";\n\n// Encoding library for Binary Object Representation\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    // DECLARE TYPES FOR EASIER REFERENCE OF VARIABLE TYPE\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    function encodeFixedNumeric(Buffer.buffer memory buf, uint8 major, uint64 value) private pure {\n        if (value <= 23) {\n            buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.appendUint8(uint8((major << 5) | 24));\n            buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.appendUint8(uint8((major << 5) | 25));\n            buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.appendUint8(uint8((major << 5) | 26));\n            buf.appendInt(value, 4);\n        } else {\n            buf.appendUint8(uint8((major << 5) | 27));\n            buf.appendInt(value, 8);\n        }\n    }\n\n    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\n        buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\n        if (value > 0xFFFFFFFFFFFFFFFF) {\n            encodeBigNum(buf, value);\n        } else {\n            encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        }\n    }\n\n    function encodeInt(Buffer.buffer memory buf, int value) internal pure {\n        if (value < -0x10000000000000000) {\n            encodeSignedBigNum(buf, value);\n        } else if (value > 0xFFFFFFFFFFFFFFFF) {\n            encodeBigNum(buf, uint(value));\n        } else if (value >= 0) {\n            encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n        } else {\n            encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n        }\n    }\n\n    function encodeBytes(Buffer.buffer memory buf, bytes memory value) internal pure {\n        encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.append(value);\n    }\n\n    function encodeBigNum(Buffer.buffer memory buf, uint value) internal pure {\n        buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        encodeBytes(buf, abi.encode(value));\n    }\n\n    function encodeSignedBigNum(Buffer.buffer memory buf, int input) internal pure {\n        buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n        encodeBytes(buf, abi.encode(uint256(-1 - input)));\n    }\n\n    function encodeString(Buffer.buffer memory buf, string memory value) internal pure {\n        encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.append(bytes(value));\n    }\n\n    function startArray(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n    }\n\n    function startMap(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n    }\n\n    function endSequence(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n    }\n}\n"
    },
    "src/mock/MockADCSConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../ADCSConsumerFulfill.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockADCSConsumer is\n    ADCSConsumerFulfillUint256,\n    ADCSConsumerFulfillBool,\n    ADCSConsumerFulfillBytes32,\n    ADCSConsumerFulfillBytes,\n    ADCSConsumerFulfillStringAndBool,\n    Ownable\n{\n    using ADCS for ADCS.Request;\n    uint256 public lastUint256;\n    bool public lastBool;\n    bytes32 public lastBytes32;\n    bytes public lastBytes;\n\n    StringAndBool public lastestMemeCoin;\n\n    event DataRequestedUint256(uint256 indexed requestId);\n    event DataRequestedBool(uint256 indexed requestId);\n    event DataRequestedBytes32(uint256 indexed requestId);\n    event DataRequestedBytes(uint256 indexed requestId);\n    event DataRequestedStringAndBool(uint256 indexed requestId);\n\n    constructor(address _coordinator) ADCSConsumerBase(_coordinator) Ownable(_msgSender()) {}\n\n    function requestUint256Data(\n        uint32 _callbackGasLimit,\n        bytes32 _jobId,\n        string memory _from,\n        string memory _to\n    ) external returns (uint256 requestId) {\n        bytes32 typeId = keccak256(abi.encodePacked(\"uint256\"));\n        ADCS.Request memory req = buildRequest(_jobId, typeId);\n        req.add(\"from\", _from);\n        req.add(\"to\", _to);\n        requestId = COORDINATOR.requestData(_callbackGasLimit, req);\n        emit DataRequestedUint256(requestId);\n    }\n\n    function requestBoolData(\n        uint32 _callbackGasLimit,\n        bytes32 _jobId,\n        string memory _from\n    ) external returns (uint256 requestId) {\n        bytes32 typeId = keccak256(abi.encodePacked(\"bool\"));\n        ADCS.Request memory req = buildRequest(_jobId, typeId);\n        req.add(\"from\", _from);\n        requestId = COORDINATOR.requestData(_callbackGasLimit, req);\n        emit DataRequestedBool(requestId);\n    }\n\n    function requestBytes32Data(\n        uint32 _callbackGasLimit,\n        bytes32 _jobId,\n        string memory _from\n    ) external returns (uint256 requestId) {\n        ADCS.Request memory req = buildRequest(_jobId, keccak256(abi.encodePacked(\"bytes32\")));\n        req.add(\"from\", _from);\n        requestId = COORDINATOR.requestData(_callbackGasLimit, req);\n        emit DataRequestedBytes32(requestId);\n    }\n\n    function requestMemeData(\n        uint32 _callbackGasLimit,\n        bytes32 _jobId\n    ) external returns (uint256 requestId) {\n        ADCS.Request memory req = buildRequest(\n            _jobId,\n            keccak256(abi.encodePacked(\"stringAndbool\"))\n        );\n        requestId = COORDINATOR.requestData(_callbackGasLimit, req);\n        emit DataRequestedBytes(requestId);\n    }\n\n    function requestBytesData(\n        uint32 _callbackGasLimit,\n        bytes32 _jobId,\n        string memory _from\n    ) external returns (uint256 requestId) {\n        ADCS.Request memory req = buildRequest(_jobId, keccak256(abi.encodePacked(\"bytes\")));\n        req.add(\"from\", _from);\n        requestId = COORDINATOR.requestData(_callbackGasLimit, req);\n        emit DataRequestedBytes(requestId);\n    }\n\n    function fulfillDataRequest(uint256, uint256 response) internal virtual override {\n        lastUint256 = response;\n    }\n\n    function fulfillDataRequest(uint256, bool response) internal virtual override {\n        lastBool = response;\n    }\n\n    function fulfillDataRequest(uint256, bytes32 response) internal virtual override {\n        lastBytes32 = response;\n    }\n\n    function fulfillDataRequest(uint256, bytes memory response) internal virtual override {\n        lastBytes = response;\n    }\n\n    function fulfillDataRequest(uint256, StringAndBool memory response) internal virtual override {\n        lastestMemeCoin = response;\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}